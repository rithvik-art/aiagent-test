import {
  Engine, Scene, FreeCamera, WebXRState, Vector3, MeshBuilder, Mesh, Color4,
  StandardMaterial, Texture, Material, TransformNode
} from "@babylonjs/core";
// Register glTF/GLB loader (prevents controller/hand model warnings)
import "@babylonjs/loaders";
import { PhotoDome } from "@babylonjs/core/Helpers/photoDome";
import { loadWalkthrough } from "./walkthrough-loader.js";

/* Config */
const FLIP_U = true, FLIP_X = true, DOME_DIAMETER = 2000, FLOOR_HEIGHT_M = 3.0;
const BASE_URL = (import.meta?.env?.BASE_URL ?? "/");
const EXPERIENCE_PREFIX = "experiences/";
const ensureExpPath = (value = "") => {
  const input = String(value || "").trim().replace(/^\/+/, "");
  const slug = input.length ? input : "skywalk";
  return slug.startsWith(EXPERIENCE_PREFIX) ? slug : `${EXPERIENCE_PREFIX}${slug}`.replace(/\/{2,}/g, "/");
};

const createMetaLookup = (list = []) => {
  const map = new Map();
  for (const entry of list) {
    const slug = typeof entry?.id === "string" ? entry.id.trim() : "";
    if (slug) map.set(slug, entry);
  }
  return map;
};

// Detect WebP support (sync)
const SUPPORTS_WEBP = (() => {
  try {
    const c = document.createElement('canvas');
    return c.toDataURL && c.toDataURL('image/webp').indexOf('image/webp') !== -1;
  } catch { return false; }
})();
const chooseFile = (f) => SUPPORTS_WEBP ? f : f.replace(/\.webp$/i, '.jpg');

export async function initViewer({ roomId = "demo", exp, experienceId, experiencesMeta = [] } = {}) {
  const metaById = createMetaLookup(experiencesMeta);
  const initialTarget = exp ?? experienceId ?? "skywalk";
  let expPath = ensureExpPath(initialTarget);
  let BASE = `${BASE_URL}${expPath}`.replace(/\/{2,}/g, "/");
  const uid = (crypto?.randomUUID?.() || Math.random().toString(36).slice(2));
  const expSlug = () => expPath.split("/").filter(Boolean).pop();
  const currentMeta = () => metaById.get(expSlug()) || {};
  const isStereo = () => Boolean(currentMeta().stereo);
  // Pano directory may switch to a mobile-optimized folder on iOS
  let PANOS_DIR = 'panos';
  const panoUrl = (f) => `${BASE}/${PANOS_DIR}/${chooseFile(f)}`.replace(/\/{2,}/g, "/");
  // UA flags (used for iOS memory-safe behavior)
  const UA = (navigator.userAgent || "").toLowerCase();
  const IS_IOS = /iphone|ipad|ipod|ios/.test(UA);
  /* Engine / Scene */
  const canvas = document.getElementById("renderCanvas");
  const engine = new Engine(canvas, true, {
    disableWebGL2Support: true,
    powerPreference: 'low-power',
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    stencil: false
  });
  try {
    // Force HQ on request; otherwise cap to 2x for perf
    function determineDpr(){
      const qs = new URLSearchParams(location.search);
      const forceHQ = (qs.get('hq') === '1') || (String(import.meta?.env?.VITE_FORCE_HQ||'')==='1') || ((qs.get('q')||'').toLowerCase()==='high');
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const cap = forceHQ ? 3 : 2;
      // iOS tends to crash with high DPR + huge textures; keep DPR conservative
      const target = Math.min(cap, dpr);
      return IS_IOS ? Math.min(1.2, target) : target;
    }
    engine.setHardwareScalingLevel(1 / determineDpr());
  } catch {}

  function getQuality() {
    try {
      // Safer defaults for iPhones (lower memory pressure)
      if (IS_IOS) return { mips: false, sampling: Texture.BILINEAR_SAMPLINGMODE, aniso: 1 };
      const qs = new URLSearchParams(location.search);
      const override = (qs.get('q') || import.meta?.env?.VITE_QUALITY || 'auto').toLowerCase();
      if (override === 'high') return { mips: true, sampling: Texture.TRILINEAR_SAMPLINGMODE, aniso: 8 };
      if (override === 'low')  return { mips: false, sampling: Texture.BILINEAR_SAMPLINGMODE, aniso: 1 };
      const conn = navigator.connection || navigator.webkitConnection || navigator.mozConnection;
      const eff = String(conn?.effectiveType || '').toLowerCase();
      const save = Boolean(conn?.saveData);
      const slow = /^(slow-)?2g|3g$/.test(eff) || save;
      const mem = Number(navigator.deviceMemory || 4);
      if (slow || mem <= 2) return { mips: false, sampling: Texture.BILINEAR_SAMPLINGMODE, aniso: 1 };
      return { mips: true, sampling: Texture.TRILINEAR_SAMPLINGMODE, aniso: 8 };
    } catch { return { mips: true, sampling: Texture.TRILINEAR_SAMPLINGMODE, aniso: 8 }; }
  }
  const scene = new Scene(engine);
  scene.clearColor = new Color4(0, 0, 0, 1);

  const cam = new FreeCamera("cam", new Vector3(0, 0, 0), scene);
  cam.attachControl(canvas, true);
  cam.inputs.clear();
  cam.fov = 1.1;
  cam.minZ = 0.1;
  cam.maxZ = 50000;

  /* Data */
  let data, nodesById, startNodeId;
  try{ window.dispatchEvent(new CustomEvent('loading:show', { detail:{ label: 'Loading tour…' } })); }catch{}
  ({ data, nodesById, startNodeId } = await loadWalkthrough(`${BASE}/walkthrough.json`));
  try{ window.dispatchEvent(new CustomEvent('loading:hide')); }catch{}
  let currentNodeId = startNodeId;

  // If on iOS or small GPUs, try a mobile-optimized folder (panos-mobile) if present
  async function maybeUseMobilePanos() {
    try {
      const maxTex = engine.getCaps()?.maxTextureSize || 4096;
      const shouldPrefer = IS_IOS || maxTex < 8192;
      if (!shouldPrefer) return;
      const startFile = (nodesById?.get?.(currentNodeId)?.file) || '';
      if (!startFile) { PANOS_DIR = 'panos'; return; }
      // Prefer 6K variant on larger iPads where available
      const probe6k = `${BASE}/panos-mobile-6k/${chooseFile(startFile)}`.replace(/\/{2,}/g, '/');
      const probe4k = `${BASE}/panos-mobile/${chooseFile(startFile)}`.replace(/\/{2,}/g, '/');
      if (maxTex >= 6144) {
        const r6 = await fetch(probe6k, { method: 'HEAD', cache: 'no-cache' });
        if (r6.ok) { PANOS_DIR = 'panos-mobile-6k'; return; }
      }
      const r4 = await fetch(probe4k, { method: 'HEAD', cache: 'no-cache' });
      if (r4.ok) { PANOS_DIR = 'panos-mobile'; }
    } catch { /* no-op: keep default */ }
  }
  await maybeUseMobilePanos();

  /* Floors -> world positions */
  const floorIndex = new Map();
  const floorCenters = new Map();
  function rebuildFloorMaps() {
    floorIndex.clear();
    floorCenters.clear();
    data.floors.forEach((f, i) => floorIndex.set(f.id, i));
    for (const f of data.floors) {
      const on = data.nodes.filter((n) => n.floorId === f.id);
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const n of on) {
        if (typeof n.x === "number" && typeof n.y === "number") {
          if (n.x < minX) minX = n.x;
          if (n.x > maxX) maxX = n.x;
          if (n.y < minY) minY = n.y;
          if (n.y > maxY) maxY = n.y;
        }
      }
      const ppm = f.pxPerMeter || 100;
      const cx = isFinite(minX) ? (minX + maxX) / 2 : 0;
      const cy = isFinite(minY) ? (minY + maxY) / 2 : 0;
      floorCenters.set(f.id, { cx, cy, ppm });
    }
  }
  rebuildFloorMaps();
  const nodeWorldPos = (n) => {
    const f = floorCenters.get(n.floorId) || { cx: 0, cy: 0, ppm: 100 };
    const idx = floorIndex.get(n.floorId) ?? 0;
    return new Vector3((n.x - f.cx) / f.ppm, idx * FLOOR_HEIGHT_M, (n.y - f.cy) / f.ppm);
  };
  /* Dome */
  const worldRoot = new TransformNode("worldRoot", scene);
  const dome = MeshBuilder.CreateSphere("dome", { diameter: DOME_DIAMETER, segments: 64, sideOrientation: Mesh.BACKSIDE }, scene);
  dome.parent = worldRoot;
  if (FLIP_X) dome.rotation.x = Math.PI;

  const domeMat = new StandardMaterial("panoMat", scene);
  domeMat.disableLighting = true;
  domeMat.backFaceCulling = false;
  domeMat.transparencyMode = Material.MATERIAL_ALPHABLEND;
  dome.material = domeMat;

  // Drag-to-rotate + pinch/wheel zoom for Viewer (2D) — immediate (no drift)
  let dragging=false, lastX=0, lastY=0;
  let yawV=0, pitchV=0;
  const yawSpeed=0.005, pitchSpeed=0.003, pitchClamp=Math.PI*0.39;
  function applyCam(){
    const px = Math.max(-pitchClamp, Math.min(pitchClamp, pitchV));
    cam.rotation.y = yawV;
    cam.rotation.x = px;
  }
  const canvas2 = document.getElementById('renderCanvas');
  if (canvas2){
    canvas2.style.cursor='grab';
    const MIN_FOV=0.45, MAX_FOV=1.7; const clampF=(v)=>Math.max(MIN_FOV, Math.min(MAX_FOV, v));
    const touches=new Map(); let pinch=false, pinRef=0, pinBase=cam.fov; const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y)||1;
    canvas2.addEventListener('pointerdown', (e)=>{
      touches.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if (touches.size===2){ const it=[...touches.values()]; pinRef=dist(it[0],it[1]); pinBase=cam.fov; pinch=true; dragging=false; canvas2.style.cursor='grab'; }
      else if (touches.size===1){ dragging=true; lastX=e.clientX; lastY=e.clientY; try{ canvas2.setPointerCapture(e.pointerId); }catch{} canvas2.style.cursor='grabbing'; }
    }, { passive:false });
    canvas2.addEventListener('pointermove', (e)=>{
      const p=touches.get(e.pointerId); if (p){ p.x=e.clientX; p.y=e.clientY; }
      if (pinch && touches.size>=2){ const it=[...touches.values()]; const cur=dist(it[0],it[1]); const scale=Math.max(0.25,Math.min(4,cur/pinRef)); cam.fov = clampF(pinBase*scale); return; }
      if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; yawV -= dx*yawSpeed; pitchV -= dy*pitchSpeed; applyCam();
    }, { passive:true });
    function endPtr(){ dragging=false; pinch=false; canvas2.style.cursor='grab'; }
    canvas2.addEventListener('pointerup', (e)=>{ touches.delete(e.pointerId); endPtr(); }, { passive:true });
    canvas2.addEventListener('pointerleave', (e)=>{ touches.delete(e.pointerId); endPtr(); }, { passive:true });
    canvas2.addEventListener('pointercancel', (e)=>{ touches.delete(e.pointerId); endPtr(); }, { passive:true });
    canvas2.addEventListener('wheel', (e)=>{ e.preventDefault(); const step=Math.max(-0.2,Math.min(0.2,(e.deltaY||0)*0.0012)); cam.fov = clampF(cam.fov + step); }, { passive:false });
  }

  // second dome for crossfade in 2D
  const dome2 = MeshBuilder.CreateSphere("dome2", { diameter: DOME_DIAMETER, segments: 64, sideOrientation: Mesh.BACKSIDE }, scene);
  dome2.parent = worldRoot; if (FLIP_X) dome2.rotation.x = Math.PI;
  const domeMat2 = new StandardMaterial("panoMatB", scene);
  domeMat2.disableLighting = true; domeMat2.backFaceCulling = false; domeMat2.transparencyMode = Material.MATERIAL_ALPHABLEND;
  domeMat.alpha = 1.0; domeMat2.alpha = 0.0; dome2.material = domeMat2;
  let activeMat = 0; const mats=[domeMat,domeMat2]; const domes=[dome,dome2];
  async function crossfadeToTexture(tex, durMs=200){
    mapFor2D(tex, isStereo());
    // On iOS, avoid double-buffer crossfade to reduce peak memory
    if (IS_IOS) {
      try { domeMat.emissiveTexture = tex; domeMat.alpha = 1.0; } catch {}
      try { dome.setEnabled(true); dome2.setEnabled(false); } catch {}
      activeMat = 0;
      return;
    }
    const from=mats[activeMat]; const to=mats[1-activeMat];
    to.emissiveTexture = tex; to.alpha = 0.0; domes[0].setEnabled(true); domes[1].setEnabled(true);
    let t0=performance.now();
    await new Promise(res=>{ const obs=scene.onBeforeRenderObservable.add(()=>{ const t=Math.min(1,(performance.now()-t0)/durMs); to.alpha=t; from.alpha=1-t; if(t>=1){ scene.onBeforeRenderObservable.remove(obs); res(); }}); });
    activeMat = 1-activeMat;
  }

  /* Texture cache & mapping */
  // LRU texture cache to prevent unbounded GPU memory growth
  const texCache = new Map();
  const inFlight = new Map();
  const TEX_LIMIT = (()=>{ try{ const ua=(navigator.userAgent||'').toLowerCase(); if(/iphone|ipad|ipod|ios/.test(ua)) return 2; if(/android/.test(ua)) return 8; return 16; }catch{ return 16; } })();
  function touchLRU(key){ if(!texCache.has(key)) return; const v=texCache.get(key); texCache.delete(key); texCache.set(key,v); }
  function evictIfNeeded(curKey){
    try{
      while (texCache.size > TEX_LIMIT){
        const firstKey = texCache.keys().next().value;
        if (!firstKey || firstKey === curKey) break;
        const tex = texCache.get(firstKey);
        try{ tex?.dispose?.(); }catch{}
        texCache.delete(firstKey);
      }
    }catch{}
  }
  function retainOnly(keep){
    try{
      for (const [k, tex] of texCache.entries()){
        if (!keep.has(k)) { try{ tex?.dispose?.(); }catch{} texCache.delete(k); }
      }
    }catch{}
  }
