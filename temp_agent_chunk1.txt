// agent.js — Agent with multi-viewer mirror grid (bottom-right), camera-driven look
// 2D stays mono (cropped if the source is TB). XR uses true TB stereo via PhotoDome.

import {
  Engine, Scene, FreeCamera, WebXRState, Vector3, MeshBuilder, Mesh, Color4,
  StandardMaterial, Texture, Material, TransformNode, Color3, PointerEventTypes, Viewport, Ray
} from "@babylonjs/core";
import "@babylonjs/loaders";
import { PhotoDome } from "@babylonjs/core/Helpers/photoDome";
import { loadWalkthrough, buildMinimapDOM } from "./walkthrough-loader.js";

/* logs */
function LOG(){ try{ console.log.apply(console, arguments); }catch{} }
function stamp(){ return new Date().toISOString().split("T")[1].slice(0,12); }
function A(tag, obj){ LOG("[AGENT]", stamp(), tag, obj||""); }

/* constants */
const FLIP_U = true, FLIP_X = true;
const DOME_DIAMETER = 2000, FLOOR_HEIGHT_M = 3.0;
const NAV_DUR_MS = 550, NAV_PUSH_M = 3.0;
let MIRROR_YAW_SIGN = 1;
let MIRROR_PITCH_SIGN = 1; // 1 for same direction, -1 to invert if needed

/* env */
let BASE_URL = (import.meta?.env?.BASE_URL ?? "/");
function toWs(url){ try{ if(!url) return null; const s=String(url); return s.replace(/^http(s?):/i, 'ws$1:'); }catch{ return url; } }
const WS_PRIMARY = toWs(import.meta?.env?.VITE_WS_URL || "wss://vrsync.dev.opensky.co.in/");
const WS_FALLBACK = toWs(import.meta?.env?.VITE_WS_URL_SECONDARY || import.meta?.env?.VITE_WS_FALLBACK || "https://22abcd9c-f607-41d5-9109-203a6cf0b79e-00-3nw6aihj3adm4.sisko.replit.dev/");
function expandWs(u){ if(!u) return []; try{ const url=new URL(u); const list=[u]; const hasPath=url.pathname && url.pathname!=='/' && url.pathname!==''; if(!hasPath){ list.push((u.endsWith('/')?u.slice(0,-1):u)+"/ws"); } return list; }catch{ return [u]; } }

// WebP support
const SUPPORTS_WEBP = (() => { try { const c = document.createElement('canvas'); return c.toDataURL && c.toDataURL('image/webp').indexOf('image/webp') !== -1; } catch { return false; } })();
const chooseFile = (f) => SUPPORTS_WEBP ? f : f.replace(/\.webp$/i, '.jpg');

const rad = d => d*Math.PI/180;
const v3arr = v => [v.x,v.y,v.z];
const expNameFrom = base => { const p=base.split("/").filter(Boolean); return p[p.length-1]||"amenities"; };
const UA = (navigator.userAgent || "").toLowerCase();
const IS_IOS = /iphone|ipad|ipod|ios/.test(UA);
const IS_ANDROID = /android/.test(UA);
const IS_MOBILE = IS_IOS || IS_ANDROID || /mobile/.test(UA);
const CROSSFADE_MODE = (import.meta?.env?.VITE_CROSSFADE || 'auto').toLowerCase();
function wantsCrossfade(){ if (CROSSFADE_MODE==='on') return true; if (CROSSFADE_MODE==='off') return false; return !IS_IOS; }

/* 2D texture mapping (mono crop for TB stereo) */
function mapFor2D(tex, stereo, flipU){
  if (!tex) return;
  tex.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MODE;
  tex.uScale  = flipU ? -1 : 1;
  tex.uOffset = flipU ?  1 : 0;
  tex.vScale  = stereo ? -0.5 : -1.0; // bottom half = right eye (adjust if top)
  tex.vOffset = 1.0;
  tex.wrapU = Texture.CLAMP_ADDRESSMODE;
  tex.wrapV = Texture.CLAMP_ADDRESSMODE;
  // aniso set when texture is created based on quality profile
}

function createMetaLookup(list = []){
  const map = new Map();
  for (const entry of list){
    const id = typeof entry?.id === 'string' ? entry.id.trim() : '';
    if (id) map.set(id, entry);
  }
  return map;
}

export async function initAgent(opts = {}){
  const roomId = (opts.roomId && String(opts.roomId).trim()) || "demo";
  const exp    = (opts.exp    && String(opts.exp).trim()) || "amenities";
  const experiencesMeta = Array.isArray(opts.experiencesMeta) ? opts.experiencesMeta : [];
  const metaById = createMetaLookup(experiencesMeta);

  let BASE = (BASE_URL + "experiences/" + exp).replace(/\/{2,}/g,"/");
  let PANOS_DIR = "panos";
  const expName  = () => expNameFrom(BASE);
  const isStereo = () => Boolean(metaById.get(expName())?.stereo);
  const panoPath = (dir, file) => (BASE + "/" + dir + "/" + chooseFile(file)).replace(/\/{2,}/g,"/");
  const panoUrl  = file => panoPath(PANOS_DIR, file);
  const WS_LIST = Array.from(new Set([ ...expandWs(WS_PRIMARY), ...expandWs(WS_FALLBACK) ].filter(Boolean)));
  A("init", { roomId, exp:expName(), BASE, ws: WS_LIST });

  /* engine/scene */
  const canvas = document.getElementById("renderCanvas");
  const engine = new Engine(canvas, true, {
    disableWebGL2Support: IS_IOS,
    powerPreference: IS_IOS ? "low-power" : "high-performance",
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    stencil: false
  });
  try{
    // Force HQ on request; allow low quality to cap DPR at 1 for speed
    function determineDpr(){
      const qs = new URLSearchParams(location.search);
      const qOverride = (qs.get('q')||'').toLowerCase();
      const forceHQ = (qs.get('hq') === '1') || (String(import.meta?.env?.VITE_FORCE_HQ||'')==='1') || (qOverride==='high');
      const forceLow = (qOverride==='low');
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      let cap = forceHQ ? 3 : 2;
      if (forceLow) cap = 1;
      const target = Math.min(cap, dpr);
      return IS_IOS ? Math.min(1.2, target) : target;
    }
    engine.setHardwareScalingLevel(1 / determineDpr());
  }catch{}

  function getQuality(){
    try{
      const qs = new URLSearchParams(location.search);
      const override = (qs.get('q') || import.meta?.env?.VITE_QUALITY || 'auto').toLowerCase();
      if (override==='high' || override==='auto') return { mips:true, sampling:Texture.TRILINEAR_SAMPLINGMODE, aniso:8 };
      if (override==='low')  return { mips:false, sampling:Texture.BILINEAR_SAMPLINGMODE, aniso:1 };
      const conn = navigator.connection || navigator.webkitConnection || navigator.mozConnection;
      const eff = String(conn?.effectiveType||'').toLowerCase();
      const save = Boolean(conn?.saveData);
      const slow = /^(slow-)?2g|3g$/.test(eff) || save;
      const mem = Number(navigator.deviceMemory || 4);
      if (slow || mem <= 2) return { mips:false, sampling:Texture.BILINEAR_SAMPLINGMODE, aniso:1 };
      return { mips:true, sampling:Texture.TRILINEAR_SAMPLINGMODE, aniso:8 };
    }catch{ return { mips:true, sampling:Texture.TRILINEAR_SAMPLINGMODE, aniso:8 }; }
  }
  const scene  = new Scene(engine);
  scene.clearColor = new Color4(0,0,0,1);

  const cam = new FreeCamera("cam", new Vector3(0,0,0), scene);
  cam.attachControl(canvas, true);
  cam.inputs.clear();
  cam.fov=1.1; cam.minZ=0.1; cam.maxZ=50000; cam.layerMask=0x1;
  scene.activeCamera = cam;

  /* data */
  try{ window.dispatchEvent(new CustomEvent('loading:show', { detail:{ label: 'Loading tour…' } })); }catch{}
  let { data, nodesById, startNodeId } = await loadWalkthrough((BASE + "/walkthrough.json").replace(/\/{2,}/g,"/"));
  try{ window.dispatchEvent(new CustomEvent('loading:hide')); }catch{}
  let currentNodeId = startNodeId;
  const experienceDataCache = new Map();

  function cloneHotspots(list){
    if (!Array.isArray(list)) return [];
    return list.map(h => ({
      to: h?.to,
      type: h?.type || "walk",
      yaw: typeof h?.yaw === 'number' ? h.yaw : 0,
      pitch: typeof h?.pitch === 'number' ? h.pitch : 0,
      dir: Array.isArray(h?.dir) ? h.dir.slice(0, 3) : undefined,
      uv: Array.isArray(h?.uv) ? h.uv.slice(0, 2) : undefined,
    }));
  }
  function cloneNodeDeep(node){
    if (!node) return null;
    return {
      id: node.id,
      file: node.file,
      floorId: node.floorId,
      x: node.x,
      y: node.y,
      z: node.z,
      yaw: node.yaw,
      zoneId: node.zoneId,
      hotspots: cloneHotspots(node.hotspots),
    };
  }
  function cloneZoneDeep(zone){
    if (!zone) return null;
    return {
      id: zone.id,
      name: zone.name,
      floorId: zone.floorId,
      repNodeId: zone.repNodeId,
      points: Array.isArray(zone.points) ? zone.points.map(p => ({ x: p.x, y: p.y })) : [],
    };
  }
  function cloneExperienceData(payload){
    if (!payload) return null;
    const src = payload.data || {};
    return {
      expId: payload.expId || expName(),
      startNodeId: src.startNodeId ?? payload.startNodeId ?? null,
      floors: Array.isArray(src.floors) ? src.floors.map(f => ({ ...f })) : [],
      nodes: Array.isArray(src.nodes) ? src.nodes.map(cloneNodeDeep) : [],
      zones: Array.isArray(src.zones) ? src.zones.map(cloneZoneDeep) : [],
    };
  }
  function rememberExperience(expId, pack){
    if (!expId || !pack) return;
    experienceDataCache.set(expId, {
      expId,
      base: pack.base ?? (BASE_URL + "experiences/" + expId).replace(/\/{2,}/g,"/"),
      data: pack.data,
      nodesById: pack.nodesById,
      startNodeId: pack.startNodeId ?? pack.data?.startNodeId ?? null,
    });
  }
  rememberExperience(expName(), { base: BASE, data, nodesById, startNodeId });

  async function loadExperiencePackage(expId){
    const key = String(expId || "").trim();
    if (!key) return null;
    if (experienceDataCache.has(key)) return experienceDataCache.get(key);
    const base = (BASE_URL + "experiences/" + key).replace(/\/{2,}/g,"/");
    try{
      const pack = await loadWalkthrough((base + "/walkthrough.json").replace(/\/{2,}/g,"/"));
      const entry = { expId: key, base, ...pack };
      rememberExperience(key, entry);
      return experienceDataCache.get(key);
    }catch{
      experienceDataCache.set(key, null);
      return null;
    }
  }

  async function maybeSelectMobilePanoDir(){
    const node = nodesById.get(startNodeId) || (nodesById.size ? nodesById.values().next().value : null);
    const file = node?.file;
    if (!file) return;
    const qs = new URLSearchParams(location.search);
    const needsMobile = qs.get('mobile') === '1'; // only when explicitly requested
    if (!needsMobile) return;
    const candidates = [];
    candidates.push("panos-mobile-6k");
    candidates.push("panos-mobile");
    for (const dir of candidates){
      const url = panoPath(dir, file);
      try{
        let res = await fetch(url, { method: "HEAD", cache: "no-store" });
        if (!res?.ok && res?.status === 405){
          res = await fetch(url, { method: "GET", cache: "no-store" });
        }
        if (res?.ok){
          PANOS_DIR = dir;
          console.info("[AGENT] Using mobile panorama folder:", dir);
          return;
        }
      }catch{}
    }
  }
  await maybeSelectMobilePanoDir();

  /* floors */
  const floorIndex=new Map(), floorCenter=new Map();
  function rebuildFloorMaps(){
    floorIndex.clear(); floorCenter.clear();
    data.floors.forEach((f,i)=>floorIndex.set(f.id,i));
    for (const f of data.floors){
      const on=data.nodes.filter(n=>n.floorId===f.id);
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
      for (const n of on){ if(typeof n.x==="number"&&typeof n.y==="number"){ if(n.x<minX)minX=n.x; if(n.x>maxX)maxX=n.x; if(n.y<minY)minY=n.y; if(n.y>maxY)maxY=n.y; } }
      const ppm=f.pxPerMeter||100; const cx=isFinite(minX)?(minX+maxX)/2:0; const cy=isFinite(minY)?(minY+maxY)/2:0;
      floorCenter.set(f.id,{cx,cy,ppm});
    }
  }
  rebuildFloorMaps();
  const nodeWorldPos = (n)=>{ const f=floorCenter.get(n.floorId)||{cx:0,cy:0,ppm:100}; const idx=floorIndex.get(n.floorId)??0; return new Vector3((n.x-f.cx)/f.ppm, idx*FLOOR_HEIGHT_M, (n.y-f.cy)/f.ppm); };

  /* main dome */
  const worldRoot = new TransformNode("worldRoot", scene);
  const dome = MeshBuilder.CreateSphere("dome",{diameter:DOME_DIAMETER,segments:64,sideOrientation:Mesh.BACKSIDE},scene);
  dome.parent=worldRoot; if(FLIP_X) dome.rotation.x=Math.PI; dome.layerMask=0x1; dome.isPickable=false;
  const domeMat=new StandardMaterial("panoMat",scene);
  domeMat.disableLighting=true; domeMat.backFaceCulling=false;
  domeMat.transparencyMode=Material.MATERIAL_ALPHABLEND; domeMat.disableDepthWrite=true;
  dome.material=domeMat; dome.renderingGroupId=0;

  // Secondary dome for optional crossfade
  const crossDome = MeshBuilder.CreateSphere("domeX",{diameter:DOME_DIAMETER,segments:64,sideOrientation:Mesh.BACKSIDE},scene);
  crossDome.parent=worldRoot; if(FLIP_X) crossDome.rotation.x=Math.PI; crossDome.layerMask=0x1; crossDome.isPickable=false; crossDome.isVisible=false;
  const crossMat=new StandardMaterial("panoMatX",scene);
  crossMat.disableLighting=true; crossMat.backFaceCulling=false; crossMat.alpha=0;
  crossMat.transparencyMode=Material.MATERIAL_ALPHABLEND; crossMat.disableDepthWrite=true;
  crossDome.material=crossMat; crossDome.renderingGroupId=1;
  let worldYaw = 0;

  /* textures */
  // LRU texture cache to prevent unbounded GPU memory growth on mobile
  const texCache=new Map(), inFlight=new Map();
  const TEX_LIMIT = IS_IOS ? 6 : (IS_ANDROID ? 10 : 16); // fewer on constrained GPUs
  const PREFETCH_LIMIT = IS_IOS ? 1 : 2;
  function touchLRU(key){
    if (!texCache.has(key)) return;
    const val = texCache.get(key);
    texCache.delete(key);
    texCache.set(key, val);
  }
  function evictIfNeeded(currentKey){
    try{
      while (texCache.size > TEX_LIMIT){
        const firstKey = texCache.keys().next().value;
        if (!firstKey || firstKey === currentKey) break;
        const tex = texCache.get(firstKey);
        try{ tex?.dispose?.(); }catch{}
        texCache.delete(firstKey);
      }
    }catch{}
  }
  function purgeTextures(){
    try{
      for (const [k,tex] of texCache.entries()){ try{ tex?.dispose?.(); }catch{} }
      texCache.clear();
    }catch{}
  }
  function retainOnly(keep){
    try{
      for (const [k, tex] of texCache.entries()){
        if (!keep.has(k)) { try{ tex?.dispose?.(); }catch{} texCache.delete(k); }
      }
    }catch{}
  }
  function retainSW(urls){ try{ const abs=(urls||[]).map(u=>{ try{ return new URL(u, location.origin).href; }catch{ return u; } }); navigator.serviceWorker?.controller?.postMessage({ type:'retain', urls: abs }); }catch{} }
  function neighborInfoFor(n, limit=2){
    const out={ files:[], keys:[], urls:[] };
    try{
      const hs=Array.isArray(n?.hotspots)? n.hotspots : [];
      for (const h of hs){
        if (!h?.to || !nodesById.has(h.to)) continue;
        const f = nodesById.get(h.to).file; if(!f || out.files.includes(f)) continue;
        out.files.push(f); out.keys.push(BASE+"|"+f); out.urls.push(panoUrl(f));
        if (out.files.length>=limit) break;
      }
    }catch{}
    return out;
  }
  function retainOnly(keep){
    try{
      for (const [k, tex] of texCache.entries()){
        if (!keep.has(k)) { try{ tex?.dispose?.(); }catch{} texCache.delete(k); }
      }
    }catch{}
  }
  function retainSW(urls){ try{ navigator.serviceWorker?.controller?.postMessage({ type:'retain', urls }); }catch{} }
  // Standard texture load: use the file as authored (with basic WebP support toggle)
  function getTexture(file){
    const key=BASE+"|"+file;
    if (texCache.has(key)) { touchLRU(key); return Promise.resolve(texCache.get(key)); }
    if (inFlight.has(key)) return inFlight.get(key);
    const p=(async()=>{
      const q=getQuality();
      const url = panoUrl(file);
      const tex = new Texture(url, scene, !q.mips, false, q.sampling);
      try{ tex.anisotropicFilteringLevel=q.aniso; }catch{}
      return await new Promise(res=>{ if (tex.isReady()) res(tex); else tex.onLoadObservable.addOnce(()=>res(tex)); })
        .then(t=>{ texCache.set(key,t); evictIfNeeded(key); return t; });
    })();
    inFlight.set(key,p); p.finally(()=>inFlight.delete(key));
    return p;
  }
  let lastMainFile = null;
  function applyMainTexture(file, tex){
    // CORRECT: In 2D, CROP stereo (bottom half only for mono view)
    mapFor2D(tex, /*stereo*/ isStereo(), FLIP_U);
    domeMat.emissiveTexture = tex;
    try{
      const currentMainKey = BASE + "|" + file;
      const keep = new Set([currentMainKey]);
      const urls = [panoUrl(file)];
      // retain previous pano
      try{
        if (typeof lastMainFile === 'string' && lastMainFile && lastMainFile !== file){
          keep.add(BASE + "|" + lastMainFile);
          urls.push(panoUrl(lastMainFile));
        }
      }catch{}
      if (typeof mirrorTexKey === 'string' && mirrorTexKey) keep.add(mirrorTexKey);
      const curNode = nodesById.get(currentNodeId);
      const neigh = neighborInfoFor(curNode, PREFETCH_LIMIT);
      neigh.files.forEach(f=>{ try{ getTexture(f).catch(()=>{}); }catch{} });
      neigh.keys.forEach(k=>keep.add(k));
      urls.push(...neigh.urls);
      retainOnly(keep);
      retainSW(urls);
      try{ lastMainFile = file; }catch{}
    }catch{}
  }
  async function showFile(file){
    // DON'T show loading overlay - causes black screens
    const tex = await getTexture(file);
    applyMainTexture(file, tex);
  }
  function runCrossFade(file, tex, fadeMs, delayMs = 0){
    if (!tex) return showFile(file);
    if (!(fadeMs > 0)) { applyMainTexture(file, tex); return Promise.resolve(); }
    mapFor2D(tex, /*stereo*/ isStereo(), FLIP_U);
    return new Promise((resolve) => {
      const startFade = () => {
        try{
          crossMat.emissiveTexture = tex;
          crossMat.emissiveTexture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MODE;
          crossMat.emissiveTexture.uScale = FLIP_U ? -1 : 1;
          crossMat.emissiveTexture.uOffset = FLIP_U ? 1 : 0;
          crossMat.emissiveTexture.vScale = isStereo() ? -0.5 : -1;
          crossMat.emissiveTexture.vOffset = 1;
          crossMat.alpha = 0;
          crossDome.isVisible = true;
        }catch{}
        const started = performance.now();
        const observer = scene.onBeforeRenderObservable.add(() => {
          const elapsed = performance.now() - started;
          const t = Math.min(1, elapsed / Math.max(1, fadeMs));
          crossMat.alpha = t;
          if (t >= 1) {
            scene.onBeforeRenderObservable.remove(observer);
            try{
              crossMat.emissiveTexture = null;
              crossDome.isVisible = false;
              crossMat.alpha = 0;
            }catch{}
            applyMainTexture(file, tex);
            resolve();
          }
        });
      };
      if (delayMs > 0) setTimeout(startFade, delayMs);
      else startFade();
    });
  }

  // Release GPU memory when tab is hidden/backgrounded (mobile stability)
  try{
    document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState !== 'visible') purgeTextures(); });
    addEventListener('pagehide', ()=>purgeTextures());
  }catch{}

  try{
    engine.onContextLostObservable.add(()=>{
      console.warn("[AGENT] WebGL context lost - purging texture cache");
      purgeTextures();
    });
    engine.onContextRestoredObservable.add(()=>{
      console.info("[AGENT] WebGL context restored");
      try{
        const cur = nodesById.get(currentNodeId);
        if (cur?.file) { getTexture(cur.file).catch(()=>{}); }
      }catch{}
    });
  }catch{}

  /* hotspots */
  const hotspotRoot = new TransformNode("hotspots", scene); hotspotRoot.parent=dome; hotspotRoot.layerMask=0x1;
  const hotspotRootXR = new TransformNode("hotspotsXR", scene); hotspotRootXR.layerMask=0x1;
  function vecFromYawPitch(yawDeg,pitchDeg,R,flipY=false){ const y=rad(yawDeg), p=rad(pitchDeg||0), cp=Math.cos(p), sp=Math.sin(p); const ySign = flipY ? -1 : 1; return new Vector3(R*Math.cos(y)*cp, ySign*R*sp, -R*Math.sin(y)*cp); }
  function clearHotspots(){ try{ hotspotRoot.getChildren().forEach(n=>n.dispose()); }catch{} try{ hotspotRootXR.getChildren().forEach(n=>n.dispose()); }catch{} }
  function buildHotspotsInRoot(node, parentRoot, flipXLocal=false, isXR=false){
    if (!node?.hotspots) return;
    const R = (DOME_DIAMETER/2) * 0.98;
    const ringRadius = isXR ? 32 : 24;
    const dotRadius = isXR ? 16 : 12;
    const pickDiameter = isXR ? 240 : 160;
    const hoverScaleFactor = isXR ? 1.18 : 1.08;
    for (const h of node.hotspots){
      const toId = h?.to; if (!toId || !nodesById.has(toId)) continue;
      const root=new TransformNode("hs-"+(toId||""),scene); root.parent=parentRoot||hotspotRoot; root.layerMask=0x1;
      const ring=MeshBuilder.CreateDisc("hsRing",{radius:ringRadius,tessellation:48,sideOrientation:Mesh.DOUBLESIDE},scene);
      const dot =MeshBuilder.CreateDisc("hsDot",{radius:dotRadius,tessellation:32,sideOrientation:Mesh.DOUBLESIDE},scene);
      const rm=new StandardMaterial("hsRingMat",scene); rm.disableLighting=true; rm.emissiveColor=new Color3(1,1,1);
      const dm=new StandardMaterial("hsDotMat",scene);  dm.disableLighting=true; dm.emissiveColor=new Color3(1,0.62,0.18);
      ring.material=rm; dot.material=dm; ring.parent=root; dot.parent=root;
      ring.billboardMode=Mesh.BILLBOARDMODE_ALL; dot.billboardMode=Mesh.BILLBOARDMODE_ALL;
      ring.isPickable=false; dot.isPickable=false;
      const pick=MeshBuilder.CreateSphere("hsPick",{diameter:pickDiameter,segments:12},scene);
      const pm=new StandardMaterial("hsPickMat",scene); pm.alpha=0.001; pm.disableLighting=true; pm.backFaceCulling=false;
      pick.material=pm; pick.parent=root; pick.isPickable=true;
      const baseScale = (root.scaling && typeof root.scaling.x === 'number') ? root.scaling.x : 1;
      const meta = {
        hotspot:true,
        to:toId,
        ring,
        dot,
        root,
        baseScale,
        hoverScale: hoverScaleFactor * baseScale
      };
      root.metadata = meta;
      ring.metadata = meta;
      dot.metadata = meta;
      pick.metadata = meta;
      // FIX: When dome is flipped (FLIP_X), invert Y coordinate for hotspots
      const v = vecFromYawPitch(h.yaw||0, h.pitch||0, R, flipXLocal);
      root.position.copyFrom(v);
      try{ root.lookAt(Vector3.Zero()); }catch{}
    }
  }
  function buildHotspotsFor(node, forXR=false){
    clearHotspots();
    if (forXR){
      buildHotspotsInRoot(node, hotspotRootXR, /*flipXLocal*/ FLIP_X, /*isXR*/ true);
      try{ hotspotRoot.setEnabled(false); hotspotRootXR.setEnabled(true); }catch{}
    } else {
      buildHotspotsInRoot(node, hotspotRoot,   /*flipXLocal*/ FLIP_X, /*isXR*/ false);
      try{ hotspotRoot.setEnabled(true); hotspotRootXR.setEnabled(false); }catch{}
    }
  }

  let hoveredHotspot = null;
  function setHotspotHover(meta, active){
    if (!meta) return;
    try{
      const ringMat = meta.ring?.material;
      const dotMat = meta.dot?.material;
      if (ringMat?.emissiveColor){
        ringMat.emissiveColor.set(active ? 0.32 : 1, active ? 0.82 : 1, active ? 1 : 1);
      }
      if (dotMat?.emissiveColor){
        dotMat.emissiveColor.set(active ? 1 : 1, active ? 0.78 : 0.62, active ? 0.4 : 0.18);
      }
      if (meta.root?.scaling){
        const base = meta.baseScale || 1;
        const scale = active ? (meta.hoverScale || base * 1.12) : base;
        meta.root.scaling.set(scale, scale, scale);
      }
    }catch{}
  }
  function updateHotspotHover(meta){
    if (hoveredHotspot === meta) return;
    if (hoveredHotspot) setHotspotHover(hoveredHotspot, false);
    hoveredHotspot = meta || null;
    if (hoveredHotspot) setHotspotHover(hoveredHotspot, true);
  }

  // 2D pick + hover highlight
  scene.onPointerObservable.add(poi=>{
    if (poi.type===PointerEventTypes.POINTERMOVE || poi.type===PointerEventTypes.POINTERDOWN){
      const hit=scene.pick(scene.pointerX,scene.pointerY,m=>m?.metadata?.hotspot===true,false,cam);
      const meta = hit?.pickedMesh?.metadata?.hotspot ? hit.pickedMesh.metadata : null;
      updateHotspotHover(meta);
    }
    if (poi.type===PointerEventTypes.POINTERUP){
      const pick=scene.pick(scene.pointerX,scene.pointerY,m=>m?.metadata?.hotspot===true,false,cam);
      const toId=pick?.pickedMesh?.metadata?.to;
      if (toId && nodesById.has(toId)) goTo(toId, { source: 'user', broadcast: true });
      updateHotspotHover(null);
    }
  });
  canvas.addEventListener("pointerleave", ()=>updateHotspotHover(null), { passive:true });
  canvas.addEventListener("pointercancel", ()=>updateHotspotHover(null), { passive:true });

  /* minimap */
  let mini=null;
  function rebuildMinimap(){
    document.querySelectorAll(".mini-wrap").forEach(el=>el.remove());
    const padByFloor = new Map(data.floors.map(f=>[f.id,{x:0,y:0}]));
    const floorMetaById = new Map(data.floors.map(f=>[f.id, f]));
    // Coordinate reference per floor: auto-detect from zones (preferred) or nodes
    const coordByFloor = new Map(); // fid -> { w, h }
    const originByFloor = new Map(); // fid -> { x, y }
    const extentsByFloor = new Map(); // fid -> { minX, minY, maxX, maxY }
    const widenExtent = (fid, x, y)=>{
      if (!fid) return;
      const px = Number(x);
      const py = Number(y);
      if (!Number.isFinite(px) || !Number.isFinite(py)) return;
      const cur = extentsByFloor.get(fid) || { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
      if (px < cur.minX) cur.minX = px;
      if (px > cur.maxX) cur.maxX = px;
      if (py < cur.minY) cur.minY = py;
      if (py > cur.maxY) cur.maxY = py;
      extentsByFloor.set(fid, cur);
    };

    // Zones support: build one marker per zone (centroid of polygon), fallback to nodes when zones absent
    const hasZones = Array.isArray(data?.zones) && data.zones.length > 0;
    const zonesByFloor = new Map(); // fid -> [{id,x,y}]
    const zoneRep = new Map();      // zoneId -> representative nodeId
    if (hasZones){
      const centroid = (pts)=>{
        if (!Array.isArray(pts) || pts.length === 0) return { x: 0, y: 0 };
        let sx=0, sy=0; for (const p of pts){ sx += Number(p?.x)||0; sy += Number(p?.y)||0; }
        return { x: sx/pts.length, y: sy/pts.length };
      };
      for (const z of (data.zones||[])){
        const c = centroid(z.points || []);
        if (!zonesByFloor.has(z.floorId)) zonesByFloor.set(z.floorId, []);
        const arr = Array.isArray(z.points) ? z.points : [];
        for (const p of arr){
          widenExtent(z.floorId, p?.x, p?.y);
        }
        let rep = (typeof z.repNodeId === 'string' && nodesById.has(z.repNodeId)) ? z.repNodeId : null;
        if (!rep){ const found = (data.nodes || []).find(n => n.zoneId === z.id); rep = found?.id || null; }
        if (!rep){ rep = startNodeId || (nodesById.size? nodesById.values().next().value?.id : null); }
        if (rep) zoneRep.set(z.id, rep);
        const repNode = rep ? nodesById.get(rep) : null;
        const repX = Number(repNode?.x);
        const repY = Number(repNode?.y);
        const useRep = Number.isFinite(repX) && Number.isFinite(repY);
        if (useRep){
          widenExtent(z.floorId, repX, repY);
        }
        zonesByFloor.get(z.floorId).push({
          id: z.id,
          x: useRep ? repX : c.x,
          y: useRep ? repY : c.y,
          label: (typeof z.name==='string'? z.name : z.id)
        });
      }
    }
    for (const n of (data.nodes||[])){
      if (!n) continue;
      widenExtent(n.floorId, n.x, n.y);
    }
    for (const f of data.floors){
      const meta = floorMetaById.get(f.id) || f || {};
      const explicitW = Number(meta?.width ?? meta?.w ?? meta?.imageWidth ?? 0) || 0;
      const explicitH = Number(meta?.height ?? meta?.h ?? meta?.imageHeight ?? 0) || 0;
      const explicitOriginX = Number(meta?.originX ?? 0) || 0;
      const explicitOriginY = Number(meta?.originY ?? 0) || 0;
      const hasExplicitSize = explicitW > 0 && explicitH > 0;
      const e = extentsByFloor.get(f.id);
      if (hasExplicitSize){
        coordByFloor.set(f.id, { w: explicitW, h: explicitH });
        originByFloor.set(f.id, { x: explicitOriginX, y: explicitOriginY });
        continue;
      }
      if (e && Number.isFinite(e.minX) && Number.isFinite(e.minY)){
        originByFloor.set(f.id, { x: e.minX, y: e.minY });
      }
      const spanX = e && Number.isFinite(e.maxX) && Number.isFinite(e.minX) ? (e.maxX - e.minX) : 0;
      const spanY = e && Number.isFinite(e.maxY) && Number.isFinite(e.minY) ? (e.maxY - e.minY) : 0;
      const fallbackW = explicitW || spanX;
      const fallbackH = explicitH || spanY;
      const w = fallbackW > 0 ? fallbackW : spanX;
      const h = fallbackH > 0 ? fallbackH : spanY;
      if (w > 0 && h > 0) coordByFloor.set(f.id, { w, h });
    }
    const coordsModePref = coordByFloor.size ? "image" : "auto";

    mini = buildMinimapDOM({
      floors:data.floors, basePath:BASE, padByFloor, coordsMode: coordsModePref, ui:"dropdown",
      panelWidth:"clamp(220px, min(52vw, 48vh), 420px)", position:"top-right", paddingPx:16,
      coordByFloor,
      originByFloor,
      onSelectNode:id=>{
        if(!id) return;
        if (hasZones && zoneRep.has(id)) { goTo(zoneRep.get(id), { source: 'user', broadcast: true }); }
        else { goTo(id, { source: 'user', broadcast: true }); }
      },
      onFloorChange:fid=>{
        if (hasZones){
          const activeZone = nodesById.get(currentNodeId)?.zoneId || null;
          const list = zonesByFloor.get(fid) || [];
          mini.renderPoints(list, activeZone);
        } else {
          const list=data.nodes.filter(x=>x.floorId===fid);
          mini.renderPoints(list,currentNodeId);
        }
      }
    });
    const cur = nodesById.get(currentNodeId) || nodesById.get(startNodeId) || (nodesById.size?nodesById.values().next().value:null);
    if (cur){
      mini.setActiveFloor(cur.floorId,true,true);
      if (hasZones){
        const list = zonesByFloor.get(cur.floorId) || [];
        const active = nodesById.get(currentNodeId)?.zoneId || null;
        mini.renderPoints(list, active);
      } else {
        mini.renderPoints(data.nodes.filter(x=>x.floorId===cur.floorId), currentNodeId);
      }
    }
  }
  rebuildMinimap();

  /* move then swap */
  function easeInOutSine(t){ return -(Math.cos(Math.PI*t)-1)/2; }
  function cubicBezier(p0, p1, p2, p3, t){
    const u = 1 - t;
    const uu = u * u;
    const tt = t * t;
    const uuu = uu * u;
    const ttt = tt * t;
    const out = p0.scale(uuu);
    out.addInPlace(p1.scale(3 * uu * t));
    out.addInPlace(p2.scale(3 * u * tt));
    out.addInPlace(p3.scale(ttt));
    return out;
  }
  function forwardPushThenSwap(nextNode, prevNode = null, options = {}){
    const duration = Number.isFinite(options?.duration) ? options.duration : NAV_DUR_MS;
    const basePush = Number.isFinite(options?.push) ? options.push : NAV_PUSH_M;
    const source = typeof options?.source === 'string' ? options.source.toLowerCase() : 'program';
    const inXRMode = inXR === true;
    const push = inXRMode ? basePush * 0.55 : basePush;
    const lerp = (a,b,t)=>a + (b - a) * Math.max(0, Math.min(1, t));
    const startPos = worldRoot.position.clone();
